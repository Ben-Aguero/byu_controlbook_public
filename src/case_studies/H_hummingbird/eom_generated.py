################################################################################
# This file was auto-generated by generate_state_variable_form.py
################################################################################
import numpy as np


def calculate_M(x, m1, m2, m3, J1x, J1y, J1z, J2x, J2y, J2z, J3x, J3y, J3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_t, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = x.flatten()  # ensure 1D
    M = np.array([[J1x, 0, -J1x*np.sin(theta)], [0, -J1y*np.sin(phi)**2 + J1y + J1z*np.sin(phi)**2 + J2y + ell_1**2*m1 + ell_2**2*m2, (J1y - J1z)*np.sin(phi)*np.cos(phi)*np.cos(theta)], [-J1x*np.sin(theta), (J1y - J1z)*np.sin(phi)*np.cos(phi)*np.cos(theta), J1x*np.sin(theta)**2 + J1y*np.sin(phi)**2*np.cos(theta)**2 + J1z*np.cos(phi)**2*np.cos(theta)**2 + J2x*np.sin(theta)**2 + J2z*np.cos(theta)**2 + J3z + ell_1**2*m1*np.cos(theta)**2 + ell_2**2*m2*np.cos(theta)**2 + m3*(ell_3x**2 + ell_3y**2)]])
    return M.squeeze()


def calculate_C(x, m1, m2, m3, J1x, J1y, J1z, J2x, J2y, J2z, J3x, J3y, J3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_t, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = x.flatten()  # ensure 1D
    C = np.array([[-J1x*psidot*thetadot*np.cos(theta) - 1/2*psidot*(psidot*(2*J1y*np.sin(phi)*np.cos(phi)*np.cos(theta)**2 - 2*J1z*np.sin(phi)*np.cos(phi)*np.cos(theta)**2) + thetadot*(-(J1y - J1z)*np.sin(phi)**2*np.cos(theta) + (J1y - J1z)*np.cos(phi)**2*np.cos(theta))) - 1/2*thetadot*(psidot*(-(J1y - J1z)*np.sin(phi)**2*np.cos(theta) + (J1y - J1z)*np.cos(phi)**2*np.cos(theta)) + thetadot*(-2*J1y*np.sin(phi)*np.cos(phi) + 2*J1z*np.sin(phi)*np.cos(phi)))], [(1/2)*J1x*phidot*psidot*np.cos(theta) + phidot*thetadot*(-2*J1y*np.sin(phi)*np.cos(phi) + 2*J1z*np.sin(phi)*np.cos(phi)) + (1/2)*psidot*thetadot*(J1y - J1z)*np.sin(phi)*np.sin(theta)*np.cos(phi) + psidot*(J1y - J1z)*(-2*phidot*np.sin(phi)**2*np.cos(theta) + phidot*np.cos(theta) - thetadot*np.sin(phi)*np.sin(theta)*np.cos(phi)) - 1/2*psidot*(-J1x*phidot*np.cos(theta) + 2*psidot*(J1x - J1y*np.sin(phi)**2 - J1z*np.cos(phi)**2 + J2x - J2z - ell_1**2*m1 - ell_2**2*m2)*np.sin(theta)*np.cos(theta) - thetadot*(J1y - J1z)*np.sin(phi)*np.sin(theta)*np.cos(phi))], [-J1x*phidot*thetadot*np.cos(theta) - 2*psidot*(phidot*(-J1y + J1z)*np.sin(phi)*np.cos(phi)*np.cos(theta) + thetadot*(-J1x + J1y*np.sin(phi)**2 + J1z*np.cos(phi)**2 - J2x + J2z + ell_1**2*m1 + ell_2**2*m2)*np.sin(theta))*np.cos(theta) + thetadot*(J1y - J1z)*(-2*phidot*np.sin(phi)**2*np.cos(theta) + phidot*np.cos(theta) - thetadot*np.sin(phi)*np.sin(theta)*np.cos(phi))]])
    return C.squeeze()


def calculate_dP_dq(x, m1, m2, m3, J1x, J1y, J1z, J2x, J2y, J2z, J3x, J3y, J3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_t, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = x.flatten()  # ensure 1D
    dP_dq = np.array([[0], [ell_1*g*m1*np.cos(theta) + ell_2*g*m2*np.cos(theta)], [0]])
    return dP_dq.squeeze()


def calculate_tau(x, u, m1, m2, m3, J1x, J1y, J1z, J2x, J2y, J2z, J3x, J3y, J3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_t, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = x.flatten()  # ensure 1D
    [f_l, f_r] = u.flatten()  # ensure 1D
    tau = np.array([[d*(f_l - f_r)], [ell_t*(f_l + f_r)*np.cos(phi)], [-d*(f_l - f_r)*np.sin(theta) + ell_t*(f_l + f_r)*np.sin(phi)*np.cos(theta)]])
    return tau.squeeze()
